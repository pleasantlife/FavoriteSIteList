Obfuscation 101 : 카카오뱅크 김용욱

0. 여기서 다루는 것
 - 안드로이드 코드의 특징
 - 바이트 코드에 대한 간략한 이해


1. 안드로이드 코드의 특징
 1) 이식에 좋은 바이트 코드를 사용
 2) 동적 컴파일에 기반한 성능 향상
 3) 의존성도 동적으로 로드
 4) 암호화되지 않은 클래스와 리소스로 구성
 5) 공간 효율적인 데이터 포맷.

1-1. 이식에 좋은 바이트 코드 사용

 1) Java Bytecode
  - 스택 기반의 VM을 사용. 스택에서 입력받고 결과도 스택으로.
  - 32비트 스택 하나의 요소가 대부분의 타입을 커버.
  - char을 사용해도 기본적으로는 메모리에 이점이 없다.
  - 64비트가 필요한 자료형(double, long)을 사용할 경우 스택 두 요소.
  - 256개의 연산 (실제로는 예약어가 많음.)
  - 스택기반은 검증이 쉬움

 2) 달빅 Bytecode
  - 레지스터 기반의 VM을 사용
  - 64K 개의 레지스터 하지만 주로 앞의 256개, 가끔은 16개만 사용
  - 32비트 레지스터 하나의 요소가 대부분의 타입을 커버
  - char을 사용해도 기본적으로는 메모리에 이점이 없다.
  - 64비트가 필요한 자료형(double, long)을 사용할 경우 레지스터 2개
  - 200여개의 연산
  - 실제 하드웨어와 매핑에 이점. 성능 상의 이점. 메모리를 덜 씀.

 3) Java와 달빅의 처리과정이 다름
  - 람다 같은 코드를 제거하여 자바 7 이하에서도 동작할 수 있도록 'desugar'가 있음.(안드로이드가 직접 만듬)
  - Dex가 필요 

 4) Dx와 D8은 무엇인가요?
  - 덱스에요.
  - apk analyzer로 두 덱스를 비교할 수 있음.

 5) 한번에 달빅 바이너리로 빌드하면 안되나요?
  - 구글이 Jack & Jill을 통해 시도 했으나 실패.

 6) 구글도 사용하는 Transform API
  - 

 7) Transformer를 만들고 싶다면
  - ASM/BCEL, Javassist, AspectJ (로우레벨, 미드레벨, 하이레벨)

 2. 동적 컴파일에 기반한 성능 향상
  
   인터프리터 vs jit vs aot

   1) 아무런 정보가 없을때는 인터프리터가 해석(느림)

 3. 의존성도 동적으로 로드

  import / export 해야하는 부분은 숨길 수 없다
  메서드명, 클래스명, 필드명이 공개된다
  안드로이드 앱의 경우 Activity, Fragment, Service 등을 외부로 공개해야 한다
  난독화 도구에 exclude/include 항목을 설정해야 함.  

  4. 암호화되지 않은 클래스와 리소스로 구성

   클래스와 리소스는 암호화되어있지 않음 (기본적인 로더가 암호화를 지원하지 않음.)
   기본 클래스 로더가 지원하지 않아 한계가 존재.

 5. 공간 효율적인 데이터 포맷

   LEB-128을 사용하여 가변 바이트(1~5바이트)로 저장
   (Little Endian Base-128)
   

안드로이드 코드를 어떻게 숨길까?
 1. 클래스/리소스에 암호화를 적용한다.
 2. 리소스 사이에 클래스를 매복시킨다.
   - 이미지 파일로 위장
- 
 3.네이티브 코드로 핵심 코드를 숨긴다.
  - ABI 세트를 맞추기 어렵다.
    (64비트를 지원하지 않는 라이브러리가 단 하나라도 있다. => 모두 32비트 라이브러리를 사용해야 함)
    
 4. 서버에 핵심 코드를 숨긴다.
  - 리얼 타임 응답성이 떨어진다. 심하면 서버 다운 시 쓸 수가 없다.

 5. 템퍼 감지를 추가한다.
  - 디버거, ptrace를 발견하는 코드를 삽입한다.
  - 에뮬레이터 등에 감지한다.
  - 해당 부분을 우회하면 대부분 앱에 진입할 수 있다는 한계가 있음.

 6. 클래스, 필드, 메서드 명을 변경한다.
  - 프로가드를 포함해 대부분의 도구가 지원하는 방식
  - 짧고 의미없이 간결한 이름으로 변경
  - 공간 복잡도도 줄이고 실행 시간에도 긍정적
  - 공격자의 인내로 해결 가능(도구마다 고유의 네이밍 패턴이 있음)

7. 리플렉션 호출을 추가한다.
 - 메서드 호출에 단계를 추가하여 해석하기 어렵게 만듦.
 - 유료 도구에서 지원
 - 리플렉션이 반복적인 패턴을 가지기 때문에 기계적으로 풀 수 있음.
 - 많은 단말에서 리플렉션 크래시가 보고됨.

8. 노이즈 추가
 - 메서드 외부에 아무런 영향이 없는 코드 추가.
 - 클래스 상태 변경, i/o, 반환값등이 없음. 

9. 제어 흐름
 - 반복문이나 분기문을 불필요하게 추가
 - if문 대신 try-catch 블록을 사용하기도 함
 - switch문을 중첩적인 레이블로 변경하기도 함
 - 브랜치를 jsr 명령(goto와 비슷)으로 변환
 - 속도를 저하


프로가드는 클래스, 필드, 메서드 명 변경 및 사용하지 않은 클래스, 필드, 메서드 제거만 수행.
- 용량이 적은 바이너리를 만들기 위함.

구글은 장기적으로 프로가드를 버리겠다는 의지. => 하지만 신기술이니 좀 지켜보자.

데이터베이스의 CAP 정리

일관성과 가용성 분할내성은 동시에 가질 수 없다.

앱에서는 성능, 보안, 안정성은 다 가질 수 있을까?